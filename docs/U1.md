# day01_06-02-25
## SP1_DietPlanPerformance

A dieter records the number of calories they consume each day in an array calories,
where calories[i] represents the calories consumed on the i-th day.
Given an integer k, the dieter evaluates every consecutive sequence of k days.
(i.e., calories[i], calories[i+1], ..., calories[i+k-1] for all 0 <= i <= n-k).
For each sequence, they calculate the total calories consumed, denoted as T:
* If T < lower, the dieter performed poorly on their diet and loses 1 point.
* If T > upper, the dieter performed well on their diet and gains 1 point.
* Otherwise, the dieter performed normally, and there is no change in points.
The dieter starts with zero points. After evaluating all sequences of k days, return the total number of points the dieter has.
Note that the total points can be negative.

Input Format:
***
* Line-1: An integer n, represents calories size
* Line-2: Space separated n integers, represents calories[]
* Line-3: An integer, represents number of days
* Line-4: An integer, represents lower value
* Line-5: An integer, represents upper value

Output Format:
***
Line-1: An integer 

Sample Input 1:
***
5
1 2 3 4 5
1
3
3

Sample Output 1:
***
0

Explanation:
***
Since k = 1, each element of the array is evaluated individually:
*  calories[0] = 1 and calories[1] = 2 are less than lower, so 2 points are lost.
*  calories[3] = 4 and calories[4] = 5 are greater than upper, so 2 points are gained.
*  The net change in points is 0.
   
Sample Input 2:
***
2
3 2
2
0
1  

Sample Output 2:
***
1

Explanation:
***
Since k = 2, the only sequence is calories[0] + calories[1] = 5, which is greater than upper.
Thus, 1 point is gained.
 
Sample Input 3:
***
4
6 5 0 0
2
1
5

Sample Output 3:
***
0

Explanation:
***
* calories[0] + calories[1] = 11 > upper, so 1 point is gained.
* calories[1] + calories[2] = 5 is within the range [lower, upper], so no change in points.
* calories[2] + calories[3] = 0 < lower, so 1 point is lost.
The net change in points is 0.

Constraints:
***
1) 1 <= k <= *calories.length* <= 10^5
2) 0 <= calories[i] <= 20000
3) 0 <= lower <= upper

```java
public class SP1_DietPlanPerformance {
	
	static int n = 0, k = 0, low = 0, high = 0, points = 0;
    static int[] calories;

    static void point(int sum) {
        if (sum < low)
            points -= 1;
        else if (sum > high)
            points += 1;
    }
    
    static void solution1();
    static void solution2();
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        calories = new int[n];
        for (int i = 0; i < n; i++)
            calories[i] = sc.nextInt();

        k = sc.nextInt();
        low = sc.nextInt();
        high = sc.nextInt();

        solution1();

        System.out.println(points);

        sc.close();
    }

	static void solution1() {
        int sum = 0;
        for (int i = 0; i <= k - 1; i++) {
            sum += calories[i];
        }
        point(sum);

        for (int i = k; i < n; i++) {
            sum -= calories[i - k];
            sum += calories[i];
            point(sum);
        }
    }
```

```java
	static void solution2() {
	    int i = 0, j = 0, sum = 0;
		while (j < n) {
	        if (j < i + k) {
				sum += calories[j];
		    } else {
		        point(sum);
	            sum -= calories[i++];
	            sum += calories[j];
			}
		    j++;
		}
```
	point(sum); is only called when  j - i == k. 
	finally j == n that means j == i+k so point(sum) not called in loop for last window.
```java
        point(sum);
    }
}    
```

in solution2 we call point for existing window i.e. before updating (late realization)
in solution1 we call point  after updating i.e. for current window


## AP1_SmallestElement

You are given an array consisting of N integers, and an integer, K.
Your task is to determine the minimum element in subarrays of size K.

Sample Input1:
***
5
10 12 14 11 15
3

Sample Output1:
***
10 11 11

Sample Input2:
***
5
5 2 1 1 1
4

Sample Output2:
***
1 1

```java
public class AP1_SmallestElement {  

    static int k = 0, len = 0, n = 0;
    static int[] nums;
    static int[] result;

    static void solution() {
        int[] window = new int[k];
        int front = 0, rear = -1, idx = 0;

        for (int i = 0; i < n; i++) {
            if (front <= rear && window[front] == i - k)
                front++;
```

	front - the oldest element in the window.
	In a well-maintained sliding window (like ours), we never accumulate multiple expired elements. 
	so while loop isnt required.
  
```java

            while (front <= rear && nums[window[rear]] >= nums[i])
                rear--;  

            rear += 1;
            window[rear] = i;

            if (i >= k - 1)
                result[idx++] = nums[window[front]];
        }
    }
```
	we migh encounter a number which could be smaller than >1 numbers in the window
	this is implementing a deque data structure using front and rear 

# day02_07-02-25

## SP2_DistinctNumbersInEachSubarray

The total number of such selections will be (N - P + 1), and for each selection, 
you must return the count of unique balloon colors.

Input Format:
-------------
Line-1: Two space-separated integers N (total number of cartoons) and P (number of cartoons selected at a time).
Line-2: N space-separated integers, representing the color of balloons inside each cartoon.

Output Format:
---------------
Line-1: Print space-separated (N - P + 1) integers, where each integer represents the number of unique balloon colors in each selection of P cartoons.

Sample Input-1:
---------------
7 4
1 2 2 3 3 4 4

Sample Output-1:
----------------
3 2 3 2

Explanation: 
------------
The number of distinct elements in each subarray of size P goes as follows:
- nums[0:3] = [1,2,2,3] so ans[0] = 3
- nums[1:4] = [2,2,3,3] so ans[1] = 2
- nums[2:5] = [2,3,3,4] so ans[2] = 3
- nums[3:6] = [3,3,4,4] so ans[3] = 2


Sample Input-2:
---------------
6 3
1 1 1 1 1 1

Sample Output-2:
----------------
1 1 1 1

Explanation:
------------
The number of distinct elements in each subarray goes as follows:
- nums[0:2] = [1,1,1] so ans[0] = 1
- nums[1:3] = [1,1,1] so ans[1] = 1
- nums[2:4] = [1,1,1] so ans[2] = 1
- nums[3:5] = [1,1,1] so ans[3] = 1


Sample Input-3:
---------------
7 3
1 2 3 4 2 1 3

Sample Output-3:
----------------
3 3 3 3 3

```java

import java.util.*;

public class SP2_DistinctNumbersInEachSubarray {

    static int[] colors, result;
    static int n = 0, p = 0, len = 0;

    static void solution() {
        int idx = 0;
        Map<Integer, Integer> freq = new HashMap<>();
        int i = 0, j = 0;
        while (j < n) {
            int next = colors[j];
            if (j < i + p) {
                freq.put(next, freq.getOrDefault(next, 0) + 1);
            } else {
                result[idx++] = freq.size();
                int old = colors[i++];
                if (freq.get(old) == 1)
                    freq.remove(old);
                else
                    freq.put(old, freq.get(old) - 1);
                freq.put(next, freq.getOrDefault(next, 0) + 1);
            }
            j++;
        }
        result[idx] = freq.size();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        p = sc.nextInt();
        len = n - p + 1;
        result = new int[len];
        colors = new int[n];
        for (int i = 0; i < n; i++) {
            colors[i] = sc.nextInt();
        }

        solution();
        for (int i = 0; i < len; i++)
            System.out.print(result[i] + " ");

        sc.close();
    }
}
```

using a count variable isnt helpful because 
when prev (i-x) is removed and count decremented
	we arent tracting if curr element is present in window already

## AP2_DuplicateWindow
Given an integer array of nums and an integer window size X, 
return true if there are duplicate values (nums[i]== nums[j])in that Window(X)
X size is always <= abs(i - j) where i and j are two distinct indices of array.

Input Format:
-------------
Line-1: An integer N, Array Size
Line-2: Space separated integers, array elements
Line-3: An integer X, window size

Output Format:
--------------
Line-1: Booelan value, true/false


Sample Input-1:
---------------
4
1 2 3 1  
3 

Sample Output-1: 
----------------
false

Sample Input-2:
---------------
6
1 2 3 3 2 3
2

Sample Output-2: 
----------------
true 

```java
import java.util.*;

public class AP2_DuplicateWindow {
    static int n = 0, x = 0, len = 0;
    static int[] nums;
    static boolean result = false;

    static void solution() {
        // Map<Integer, Integer> freq = new HashMap<>();
        Set<Integer> set=new HashSet<>();
        for (int i = 0; i < n; i++) {
            // int iter = 0;
            
            if (i >= x) {
                // for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
                //     if (entry.getValue() > 1) {
                //         result = true;
                //         break;
                //     }
                //     iter++;
                // }
                // System.out.println(i + " " + iter);
                int prev = nums[i - x];
                set.remove(prev);
            }
            int curr = nums[i];

            if(set.contains(curr)) {
                result=true;
                break;
            }

            set.add(curr);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        nums = new int[n];
        for (int i = 0; i < n; i++)
            nums[i] = sc.nextInt();

        x = sc.nextInt();

        solution();

        System.out.println(result);
        sc.close();
    }
}
```
### Why This Works Efficiently
Maintains a fixed window of size x
    When i >= x, we remove the element nums[i-x], which is sliding out of the window.
    This ensures the set only contains elements from the current window.
Checks for duplicates before adding a new element
    If nums[i] already exists in set, we immediately detect a duplicate and exit.
O(N) Time Complexity
    Each element is inserted and removed exactly once → O(1) per operation.
    Total time complexity → O(N) (optimal).
